# Import necessary libraries
import streamlit as st
import os
from authenticator import Authenticator
from validator import Validator
from session_state import SessionState
from utils import generate_random_pw
import pandas as pd
import plotly.express as px
import matplotlib.pyplot as plt
import seaborn as sns
from sklearn.preprocessing import StandardScaler
from sklearn.impute import SimpleImputer
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from xgboost import XGBClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.pipeline import Pipeline
import warnings
import plotly.graph_objects as go
import numpy as np
import pickle

# Login page function
def login_page():
    st.title("Login")
    username = st.text_input("Username")
    password = st.text_input("Password", type="password")

    session_state = SessionState.get(login_success=False)

    if st.button("Login"):
        auth = Authenticator()
        try:
            auth.login(username, password)
            session_state.login_success = True
            st.experimental_rerun()
        except Exception as e:
            st.error(f"Login failed: {str(e)}")

    # Add functionality for creating account
    st.write("Don't have an account? Create one below.")
    new_username = st.text_input("New Username")
    new_password = st.text_input("New Password", type="password")
    confirm_password = st.text_input("Confirm Password", type="password")

    if st.button("Create Account"):
        validator = Validator()
        if not validator.validate_username(new_username):
            st.error("Invalid username format. Please use only alphanumeric characters, underscores, and hyphens.")
        elif new_password != confirm_password:
            st.error("Passwords do not match.")
        else:
            hashed_password = generate_random_pw()
            auth.create_account(new_username, hashed_password)
            st.success("Account created successfully. You can now log in.")

# Home page function
def home_page():
    st.title("Welcome to Churn Prediction App")
    st.write("This is a Streamlit app for predicting churn.")
    image_filename = "home.png"
    home_image_path = os.path.join("images", image_filename)
    st.image(home_image_path, caption="Home Image", use_column_width=True)

# Data page function
def data_page():
    st.title("Data Analysis")
    current_dir = os.getcwd()
    dataset_path = os.path.join(current_dir, 'dataset', 'Churn Prediction Dataset.csv')
    df = pd.read_csv(dataset_path)
    st.subheader("Basic Information about the Dataset")
    st.write(df.info())
    st.subheader("Summary Statistics of Numerical Variables")
    st.write(df.describe())
    st.subheader("First Few Rows of the Dataset")
    st.write(df.head())
    st.subheader("Missing Values")
    st.write(df.isnull().sum())
    st.subheader("Duplicate Rows")
    st.write(df.duplicated().sum())
    st.subheader("Distribution of Churn")
    fig_churn_distribution = px.histogram(df, x='Churn', title='Distribution of Churn')
    st.plotly_chart(fig_churn_distribution)
    st.subheader("Monthly Charges vs Churn")
    plt.figure(figsize=(10, 6))
    sns.boxplot(x='Churn', y='MonthlyCharges', data=df, palette='Set2')
    plt.title('Monthly Charges vs Churn')
    plt.xlabel('Churn')
    plt.ylabel('Monthly Charges')
    st.pyplot()
    st.subheader("Churn Prediction Dataset")
    st.dataframe(df.style.format({'MonthlyCharges': '${:,.2f}', 'TotalCharges': '${:,.2f}'})
                 .format({'Tenure': '{:,d}'})
                 .format({'ChurnRate': '{:.2%}'})
                 .format({'CustomerID': '{:,.0f}'})
                 .hide(subset=['Gender', 'SeniorCitizen'])
                 .set_table_styles([
                     {'selector': 'th.row_heading', 'props': [('background-color', '#3498db'), ('color', 'white')]},
                     {'selector': 'th.col_heading', 'props': [('background-color', '#e74c3c'), ('color', 'white')]},
                     {'selector': 'td', 'props': [('background-color', '#ecf0f1')]}
                 ])
                 .set_properties(**{'text-align': 'center', 'border': '1px solid black'}))

# Define the predict_online function
    def predict_online():
        # Add image
        st.image("images/image.png", use_column_width=True)

        col1, col2, col3 = st.columns(3)

        with col1:
            st.header('Demographics')
            gender = st.selectbox('Gender', ['Male', 'Female'])
            senior_citizen = st.selectbox('Senior Citizen', ['No', 'Yes'])
            partner = st.selectbox('Partner', ['No', 'Yes'])
            dependents = st.selectbox('Dependents', ['No', 'Yes'])

        with col2:
            st.header('Services')
            phone_service = st.selectbox('Phone Service', ['No', 'Yes'])
            multiple_lines = st.selectbox('Multiple Lines', ['No', 'Yes'])
            internet_service = st.selectbox('Internet Service', ['DSL', 'Fiber optic', 'No'])
            online_security = st.selectbox('Online Security', ['No', 'Yes', 'No phone service'])
            online_backup = st.selectbox('Online Backup', ['No', 'Yes', 'No Internet'])
            device_protection = st.selectbox('Device Protection', ['No', 'Yes', 'No phone service'])
            tech_support = st.selectbox('Tech Support', ['No', 'Yes', 'No phone service'])
            streaming_tv = st.selectbox('Streaming TV', ['No', 'Yes', 'No phone service'])
            streaming_movies = st.selectbox('Streaming Movies', ['No', 'Yes', 'No phone service'])

        with col3:
            st.header('Payments')
            contract = st.selectbox('Contract', ['Month-to-month', 'One year', 'Two year'])
            paperless_billing = st.selectbox('Paperless Billing', ['No', 'Yes'])
            payment_method = st.selectbox('Payment Method', ['Electronic check', 'Mailed check', 'Bank transfer (automatic)', 'Credit card (automatic)'])
            monthly_charges = st.number_input('Monthly Charges', min_value=0)
            total_charges = st.number_input('Total Charges', min_value=0)
            tenure = st.number_input('Tenure', min_value=0)

        if st.button('Predict'):
            input_data = pd.DataFrame({
                'gender': [gender],
                'SeniorCitizen': [senior_citizen],
                'Partner': [partner],
                'Dependents': [dependents],
                'tenure': [tenure],
                'PhoneService': [phone_service],
                'MultipleLines': [multiple_lines],
                'InternetService': [internet_service],
                'OnlineSecurity': [online_security],
                'OnlineBackup': [online_backup],
                'DeviceProtection': [device_protection],
                'TechSupport': [tech_support],
                'StreamingTV': [streaming_tv],
                'StreamingMovies': [streaming_movies],
                'Contract': [contract],
                'PaperlessBilling': [paperless_billing],
                'PaymentMethod': [payment_method],
                'MonthlyCharges': [monthly_charges],
                'TotalCharges': [total_charges]
            })

            # Preprocess data
            preprocessed_data = preprocessor.transform(input_data)

            selected_model = st.session_state.get('model', 'DecisionTree')
            if selected_model == 'DecisionTree':
                model = dt_model
            else:
                model = rf_model

            prediction = model.predict_proba(preprocessed_data)
            churn_percentage = prediction[0][1] * 100
            st.success(f'Churn Percentage ({selected_model} Model): {churn_percentage:.2f}%')

            # Visualize churn risk
            st.subheader("Churn Risk Meter")
            colors = ['#8A2BE2', '#FFFF00', '#FFA500']  # Violet, Yellow, Orange
            thresholds = [20, 40]
            levels = ['Low Churn Risk', 'Medium Churn Risk', 'High Churn Risk']
            risk_level = np.digitize(churn_percentage, thresholds, right=True)

            fig = go.Figure(go.Indicator(
                mode="gauge+number",
                value=churn_percentage,
                title={'text': "Churn Risk"},
                gauge={
                    'axis': {'range': [None, 100], 'tickwidth': 1, 'tickcolor': "black"},
                    'bar': {'color': colors[risk_level]},
                    'steps': [
                        {'range': [0, thresholds[0]], 'color': colors[0]},
                        {'range': [thresholds[0], thresholds[1]], 'color': colors[1]},
                        {'range': [thresholds[1], 100], 'color': colors[2]}
                    ],
                }
            ))

            fig.update_layout(paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)')
            st.plotly_chart(fig)

            st.write(f"Churn Percentage: {churn_percentage:.2f}%")

    # Call the function based on the user's choice
    predict_batch()  # Or predict_online() depending on your preference


# Dashboard page function
def dashboard_page():
    import streamlit as st
    import pandas as pd
    import matplotlib.pyplot as plt
    import seaborn as sns
    import altair as alt
    from streamlit_metrics import metric, metric_row
    import pygal
    import leather
    import plotly.express as px

    # Load the dataset
    dataset_path = 'dataset/Churn Prediction Dataset.csv'
    df = pd.read_csv(dataset_path)

    # Convert 'TotalCharges' column to numerical values
    df['TotalCharges'] = pd.to_numeric(df['TotalCharges'], errors='coerce')

    # Set page title
    st.set_page_config(page_title="Visualization Dashboard")

    # Title for the page
    st.title("Visualization Dashboard")

    # Sidebar navigation
    option = st.sidebar.selectbox(
        'Select:',
        ('Analytics Dashboard', 'Key Performance Indicators for Churn Prediction')
    )

    if option == 'Analytics Dashboard':
        # Research question 1: Distribution of churn for different Internet service types
        st.header("Research question 1: Distribution of churn for different Internet service types")

        # Using Plotly Express
        fig = px.bar(df, x='InternetService', color='Churn', barmode='group',
                    title='Churn Distribution for Internet Service Types (Plotly Express)',
                    category_orders={'InternetService': ['DSL', 'Fiber optic', 'No']},
                    color_discrete_map={'No': 'lightgreen', 'Yes': 'yellow'})
        fig.update_xaxes(title="Internet Service Type")
        fig.update_yaxes(title="Count")
        st.plotly_chart(fig)

        # Research question 2: Impact of having a partner or dependents on customer churn
        st.header("Research question 2: Impact of having a partner or dependents on customer churn")

        # Using Altair
        partner_chart = alt.Chart(df).mark_bar().encode(
            x=alt.X('Partner:O', title='Partner Status'),
            y=alt.Y('count():Q', title='Count'),
            color='Churn:N'
        ).properties(
            title="Churn Distribution for Partner Status (Altair)"
        )
        st.altair_chart(partner_chart, use_container_width=True)

        dependents_chart = alt.Chart(df).mark_bar().encode(
            x=alt.X('Dependents:O', title='Dependents Status'),
            y=alt.Y('count():Q', title='Count'),
            color='Churn:N'
        ).properties(
            title="Churn Distribution for Dependents Status (Altair)"
        )
        st.altair_chart(dependents_chart, use_container_width=True)

        # Research question 3: Influence of contract type on customer churn
        st.header("Research question 3: Influence of contract type on customer churn")

        # Using Plotly Express
        fig2 = px.histogram(df, x='Contract', color='Churn', barmode='group')
        fig2.update_layout(title="Churn Distribution for Contract Type (Plotly Express)")
        st.plotly_chart(fig2, use_container_width=True)

        # Research question 4: Impact of billing preference on customer churn
        st.header("Research question 4: Impact of billing preference on customer churn")

        # Convert 'Churn' column to boolean (0 for No, 1 for Yes)
        df['Churn'] = df['Churn'].map({'No': 0, 'Yes': 1})

        # Group data by Billing Preference and calculate churn
        billing_churn = df.groupby('PaperlessBilling')['Churn'].sum().reset_index()

        # Plot using Plotly Express
        fig = px.bar(billing_churn, x='PaperlessBilling', y='Churn', 
                    labels={'PaperlessBilling': 'Billing Preference', 'Churn': 'Churn Count'},
                    title='Churn Distribution for Billing Preference (Plotly Express)')
        st.plotly_chart(fig)

        # Using Altair
        gender_chart = alt.Chart(df).mark_bar().encode(
            x=alt.X('gender', title='Gender'),
            y=alt.Y('count()', title='Count'),
            color='Churn:N'
        ).properties(
            title="Churn Distribution by Gender (Altair)"
        )
        st.altair_chart(gender_chart, use_container_width=True)

        # Additional research questions
        st.header("Additional Research Questions")

        # Research question 6: Impact of tenure on customer churn
        st.header("Research question 6: Impact of tenure on customer churn")

        # Plot using Plotly Express
        fig = px.histogram(df, x='tenure', color='Churn', nbins=20,
                        labels={'tenure': 'Tenure', 'Churn': 'Churn'},
                        title='Impact of Tenure on Customer Churn')
        st.plotly_chart(fig)

        # Research question 7: Relationship between total charges and churn
        st.subheader("Research question 7: Relationship between total charges and churn")
        charges_churn_scatter = alt.Chart(df).mark_circle(size=60).encode(
            x='TotalCharges',
            y='Churn',
            color='Churn:N',
            tooltip=['TotalCharges', 'Churn']
        ).properties(
            title="Churn vs Total Charges (Altair)"
        ).interactive()
        st.altair_chart(charges_churn_scatter, use_container_width=True)


        
    elif option == 'Key Performance Indicators for Churn Prediction':
        # Key Performance Indicators (KPIs)
        st.header("Key Performance Indicators (KPIs)")

        # Calculate Gross MRR Churn
        gross_mrr_churn = 0.05  # Example value, replace with actual calculation

        # Calculate Net MRR Churn
        net_mrr_churn = 0.03  # Example value, replace with actual calculation

        # Calculate Net Change in Customers
        net_change_customers = 100  # Example value, replace with actual calculation

        # Calculate Revenue Growth Rate
        revenue_growth_rate = 0.10  # Example value, replace with actual calculation

        # Calculate Activation Rate
        activation_rate = 0.75  # Example value, replace with actual calculation

        # Calculate DAU/MAU Ratio
        dau_mau_ratio = 0.65  # Example value, replace with actual calculation

        # Calculate Net Promoter Score (NPS)
        nps = 75  # Example value, replace with actual calculation

        # Calculate Customer Satisfaction Score (CSAT)
        csat = 85  # Example value, replace with actual calculation

        # Calculate Customer Lifetime Value (LTV)
        clv = 1500  # Example value, replace with actual calculation

        # Display metrics in columns
        col1, col2 = st.columns(2)

        with col1:
            st.subheader("Financial Metrics")
            metric("Gross MRR Churn", f"<span style='color:green'>{gross_mrr_churn}</span>")
            metric("Net MRR Churn", f"<span style='color:yellow'>{net_mrr_churn}</span>")
            metric("Net Change in Customers", f"<span style='color:blue'>{net_change_customers}</span>")
            metric("Revenue Growth Rate", f"<span style='color:pink'>{revenue_growth_rate}</span>")

        with col2:
            st.subheader("Product Metrics")
            metric("Activation Rate", f"<span style='color:purple'>{activation_rate}</span>")
            metric("DAU/MAU Ratio", f"<span style='color:orange'>{dau_mau_ratio}</span>")
            metric("Net Promoter Score (NPS)", f"<span style='color:green'>{nps}</span>")
            metric("Customer Satisfaction (CSAT)", f"<span style='color:yellow'>{csat}</span>")
            metric("Customer Lifetime Value (LTV)", f"<span style='color:blue'>{clv}</span>")


#History page function:
import streamlit as st

class History:
    def __init__(self):
        self.history = []

    def add_entry(self, entry):
        self.history.append(entry)

    def display_history(self):
        st.header("History")
        for i, entry in enumerate(self.history):
            st.write(f"{i+1}. {entry}")

def history_page():
    # Create a shared instance of the History class
    history = History()

    # Home page
    if st.button("Home"):
        history.add_entry("Visited Home page")

    # Login page
    if st.button("Login"):
        history.add_entry("Logged in")

    # Upload dataset
    uploaded_file = st.file_uploader("Upload Dataset (CSV)", type=["csv"])
    if uploaded_file is not None:
        history.add_entry("Dataset uploaded")

    # Prediction
    if st.button("Predict"):
        # Perform prediction
        prediction_result = predict_function()  # Call your prediction function
        history.add_entry(f"Prediction: {prediction_result}")

    # View dashboards
    if st.button("Dashboards"):
        history.add_entry("Viewed dashboards")

    # Display history
    history.display_history()

    # Go back to previous points in history
    go_to_history = st.selectbox("Go to history entry", [i+1 for i in range(len(history.history))])
    if st.button("Go"):
        st.experimental_rerun(go_to_history)


# Main function to handle routing based on user input
def main():
    # Add sidebar navigation
    option = st.sidebar.selectbox("Select Page", ["Login", "Home", "Data", "Predictor", "Dashboard", "History"])

    # Route to the appropriate page based on user selection
    if option == "Login":
        login_page()
    elif option == "Home":
        home_page()
    elif option == "Data":
        data_page()
    elif option == "Predictor":
        predictor_page()
    elif option == "Dashboard":
        dashboard_page()
    elif option == "History":
        history_page()

if __name__ == "__main__":
    main()